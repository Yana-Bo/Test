"""
Создать класс "Граф", который имеет атрибуты вершины и ребра,
и методы добавления и удаления вершин и ребер, и проверки связности графа.

Класс с двумя атрибутами: множество вершин и множество рёбер. Реализованы простые методы
для добавления/удаления вершин и ребер. Метод проверяющий связность графа выполняет обход
в ширину и запоминает все посещенные вершины. Если после окончания все вершины графа помещены, то граф связен

"""

class Graph:
    def __init__(self, vs, es):
        """
        Конструктор графа с заданными мниожествами рёбер и вершин
        :param vs: множество вершин
        :param es: множетство рёбер - каждое ребро - пара элементов из множества вершин
        """
        # присваиваем атрибут множества вершин
        self.vs = vs
        # инициализируем атрибут множества рёбер пустым списком
        self.es = []
        # каждой из рёбер множества es пробуем добавить в граф
        for e in es:
            self.add_e(e)


    def add_v(self, v):
        """
        Метод для добавления вершин в граф
        :param v: новая вершина
        :return: None
        """
        # добавляем вершину, если её еще не было
        if v not in self.vs:
            self.vs.append(v)

    def rem_v(self, v):
        """
        Метод для удаления вершины из графа
        :param v: вершина, которую нужно удалить
        :return: None
        """
        # если вершины не было в графе, ничего не делаем
        if v not in self.vs:
            return
        # создаём временный список рёбер.
        # в него будем помещать все рёбра, которые остались в графе после удаления вершины
        temp_es = []
        for e in self.es:
            # если конец ребра e сопадает с вершиной этого ребра больше не будет, не добавляем его в es
            if e[0] != v and e[1] != v:
                temp_es.append(e)
        # записываем temp_es во временный атрибут
        self.es = temp_es
        # удаляем вершину из атрибута множества вершин
        self.vs.remove(v)

    def add_e(self, e):
        """
        Метод для добавления ребра в граф
        :param e: новое ребро
        :return: None
        """
        # если один из концов не в графе - не добавляем ребро
        if e[0] not in self.vs or e[1] not in self.vs:
            return
        # если ребро уже есть в графе (или развёрнутое) - не добавляем его еще раз
        if e in self.es or (e[1], e[0]) in self.es:
            return
        # иначе добавляем
        self.es.append(e)

    def rem_e(self, e):
        """
        Метод для удаления ребра из графа
        :param e: ребро, которое надо удалить
        :return: None
        """
        # если ребро еть в графе, удаляем
        if e in self.es:
            self.es.remove(e)
            return

        # если развёрнутое ребро есть в графе, удаляем
        if (e[1], e[0]) in self.es:
            self.es.remove((e[1], e[0]))
            return

    def check_connected(self):
        """
        Метод для проверки связности графа
        :return: True, если граф связный, False - если несвязный
        """
        # Получаем число вершин в графе
        n = len(self.vs)
        # если в графе нет вершин, возвращаем true
        if n == 0:
            return True
        v = self.vs[0]

        # простая реализация обхода в ширину - нужно проверить, что посетим все вершины графа
        # список посещённых вершин
        visited = []
        # очередь обхода
        queue = []
        # добавляем стартовую вершину в очередь
        queue.append(v)
        # продолжаем, пока очередь не пустая
        while len(queue) > 0:
            # извлекаем следующий элемент из очереди
            curr = queue[0]
            del queue[0]
            # если он уже посещен, берём следующий
            if curr in visited:
                continue
            # если он не посещен, добавляем в посещённые
            visited.append(curr)
            # перебираем все рёбра и добавляем в очередь все вершины, смежные с вершиной curr
            for e in self.es:
                if e[0] == curr:
                    queue.append(e[1])
                if e[1] == curr:
                    queue.append(e[0])
        # если посетили все вершины, значит граф был связный
        return n == len(visited)

# тест. До добавления последнего ребра граф должен оставаться несвязным
g = Graph([0,1,2,3,4,5], [(0,1), (4,5)])
print(g.check_connected())
g.add_e((1,2))
print(g.check_connected())
g.add_e((0,2))
print(g.check_connected())
g.add_e((3,4))
print(g.check_connected())
g.add_e((3,5))
print(g.check_connected())
g.add_e((3,2))
print(g.check_connected())
