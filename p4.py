"""
Написать программу, которая находит все уникальные комбинации элементов заданного списка,
таких, что их сумма равна заданному числу.

Подход состоит в генерации всех возможных подмножеств данного списка и проверки суммы каждого
из этих подмножеств: если сумма совпадает с целевой, запоминаем это подмножество, как одно из решений.
Генерация подмножеств происходит через генерацию всевозможных двоичных векторов длины n (длина исходного списка).
Каждому двоичному вектору однозначно сопоставляются подмножество (1 - выбираем элемент, 0 - не выбираем).
Двоичные вектора генерируются в лексикографическом порядке (в порядке возрастания двоичных чисел)

"""

def solve(arr, total):
    """
    Метод для нахождения уникальных комбинаций элементов заданного списка с искомой суммой
    :param arr: входной список
    :param total: искомая сумма
    :return: Список уникальных комбинаций с заданной суммой
    """
    # вычисляем длину входного списка
    length = len(arr)
    # bin --- массив из 0 и 1 длины length, кодирующий выбор подмножетсва:
    # 0 - не берём в подмножество, 1 - берём
    bin = [0] * length
    # список result будет содержать искомые подмножетсва
    result = []
    # будем повторять, пока не сгенерируем все возможные двоичные массивы длины length
    while True:
        # строим подсписок и находим сумму этого подсписка, соответствующий текущему состоянию двоичного массива bin
        subsum = 0
        sublist = []
        # перебираем все позиции в bin
        for i in range(length):
            # если на i-й позиции стоит 1, то добавляем arr[i] в подсписок, увеличиваем сумму subsum на величину arr[i]
            if bin[i] == 1:
                sublist.append(arr[i])
                subsum += arr[i]
        # если после прохождения по bin сумма оказалась равной total, добавляем подсписок в result, так как его сумма равна total
        if subsum == total:
            result.append(sublist)

        # теперь нужно сгенерировать слежующий двоичный массив.
        # генерация происходит в порядке возрастания соответствующих двоичных чисел
        # переменная changed хранит информацию, изменился ли хотя бы один 0 на 1 в рамках прохода по массиву bin
        # если нет, это означает, что все 1 поменялись на 0, мы вернулись к исходному двоичному массиву и генерацию нужно остановить
        changed = False
        # идём по массиву bin:
        for i in range(length):
            # если встретили компоненту, равную 0, то просто увеличиваем её и останавливаем шаг, изменив changed
            if bin[i] == 0:
                changed = True
                bin[i] = 1
                break
            else:
                # если компонента равна 1, меняем её на 0 и продолжаем идти
                bin[i] = 0
        # если ни один 0 не сменился на 1, вызодим из цикла
        if not changed:
            break

    return result

# тест 1
test1 = [1,2,3,4,5,6,7,8,9,0,9,8,7,6,5,4,3,2,1]
for a in solve(test1, 13):
    print(a)
print()

# тест 2
test2 = [1,2,3,4,5,6,7,8,9,0,9,8,7,6,5,4,3,2,1]
for a in solve(test2, 0):
    print(a)
print()

